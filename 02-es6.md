## Variáveis

### Let
O let ele é super util quando queremos criar variavel não quer correr o risco dessas variaveis serem restritas em outros trechos de código. E pode ser reatribuido um valor
```
var animal = 'cat'
{
  let animal = 'dog'
  console.log(animal)//dog
}
console.log(animal)//cat

animal = 'dog'
console.log(animal)//dog
```
### const
O const, não podemos reatribuir um valor, não podemos modificar o valor. Mas podemos alterar suas propriedades do objeto. ele não é um objeto imutável.
```
const secretNumber = 28
secretNumber = 10 //não posso fazer isso e vai dar erro

const will = { age:53 }
console.log(will.age)//53

will.age = 26
console.log(will.age)//26
```


## Temporal dead zone

O js ele faz o hoisting, ele vai ler o código e atribuir tudo em cima, como se fosse global, já que estou utilizando o var

```
console.log(cat)//undefined, cat foi definida mas não atribuiu valor
var cat = 'miau'

console.log(cat)//is not defined, já da um erro diferente
const cat = 'miau'
```


## Arrow functions

```
const ireland = ['Dublin','Galway']
const love = ireland.map((name)=>{
  return `I love ${name}`
})
console.log(love)//['I love Dublin','I love Galway']

//single line
const love = ireland.map( name => `I love ${name}`)
console.log(love)//['I love Dublin','I love Galway']

//encadeado
const loveDublin = ireland
  .filter( name=> name==='Dublin')
  .map( name=> `I love ${name}`)
console.log(love)//['I love Dublin']
```

Uma coisa que precisamos prestar atenção é com o this, o this é o objeto pelo qual estamos interagindo nesse contexto. Como por exemplo, o this nesse caso representa o btn.
```
const btn =document.getElementById('btn')
btn.addEventListener('click',function(){
  console.log(this)//<div class='btn'>click me</div>
})
```
Mas se usarmos a arrow function, é diferente, ela pega o contexto onde de tudo que estou no caso window, o arrow function seu contexto é lexico.
```
const btn =document.getElementById('btn')
btn.addEventListener('click',()=> {
  console.log(this)//window
})
```
Usando function
```
const sandwich = {
  bread: 'white',
  cheese: 'cheddar',
  prepare: function() {
    return `I want a sandwich with ${this.bread}`;
  },
  make: function() {
    window.setTimeout(function(){
      //this é o window, então não existe prepare() nesse contexto
      console.log( this.prepare() );
    }, 500);
  }
};
```
Usando Arrow function
```
const sandwich = {
  bread: 'white',
  cheese: 'cheddar',
  prepare: function() {
    return `I want a sandwich with ${this.bread}`;
  },
  make: function() {
    window.setTimeout(() => {
      //this é o sandwich, e sandwich tem a função prepare
      console.log( this.prepare() );
    }, 500);
  }
};
```


## Template Literals

Permite contacatenar strings de uma forma bem mais simples

```
const city = 'Dublin'
const text = `I love ${city}` //I love Dublin
```

Usando para html fragments
```
const article = {
  title: 'Aprendendo Template Strings',
};

const markup = `
  <article>
    <header>
      <h1>${article.title}</h1>
    </header>
  </article>
`;
```
## Shorthand Properties

Se a propriedade e a variavel tiver o mesmo nome, basta deixar só a variavel que ele vai entender

```
let firstName = 'Willian';
let surname = 'Justen';
let age = 26;

const person = {
  firstName,
  surname,
  age
};
```
## Default parameters

```
function hello (name = 'Willian', surname = 'Justen') {
  console.log(`Hello ${name} ${surname}! How are you?`);
}

hello(); //Hello Willian Justen! How are you?
hello('Jonas', 'Mendes'); //Hello Jonas Mendes! How are you?
```

## Array.from()
Ele trasforma elementos similares ao array, em array de fato
```
const text = 'Leo';
console.log(Array.from(text));//['L','e','o']

const list = document.querySelectorAll('#list li');
const listArray = Array.from(list)
console.log(listArray); //nodelist

const names = listArray.map((name) => name.textContent);
console.log(names);//agora é um array
```
## Array.find() e Array.findIndex()

O find diferente do filter, ele retorna somente o primeiro item encontrado.
```
const data = [
  {
    name: 'Willian',
    age: 26,
    city: 'Dublin'
  },
  {
    name: 'Jonas',
    age: 22,
    city: 'Cologne'
  }
];

const sampleArray = [4, -5, 0, -1];

//retorna o primeiro elemento, no caso -5
const underZero = sampleArray.find(x => x < 0);

//retorna o indece onde encontrou esse primeiro elemento, no caso 1
const underZeroIndex = sampleArray.findIndex(x => x < 0);

//pega o objeto que tenha a proprieda com nome igual a 'Jonas'
const jonas = data.find(person => person.name === 'Jonas');

//retorna o indice no caso 1
const jonasIndex = data.findIndex(person => person.name === 'Jonas');

```

## Destructuring

Permite pegar elementos e criar variaveis apartir de objetos ou arrays de forma bem simples

```
var data = {
  name: 'Willian',
  surname: 'Justen',
  age: 25,
  blog: 'https://willianjusten.com.br',
};

const { name, surname } = data;
console.log(name);//'Willian'

//renomear variavel
const { name: firstName } = data;
console.log(firstName);//'Willian'

//valor default
const { city = 'Dublin' } = data;
console.log(city);//'Dublin'
```
E no array
```
const arr = ['Willian', 'Justen', 26, 'Dublin'];
const [ name, surname ] = arr;
console.log(name);
console.log(surname);
```
## Spread operator

Ele serve para pegar elementos que são iteraveis como por exemplo um array ou strings,  e desmembrar em pequenas partes.

```
let front = ['react', 'vue''];
let back = ['python', 'nodejs'];
let fullStack = [];

//fazendo concat
fullStack = fullStack.concat(front);
fullStack.push('RxJS');
fullStack = fullStack.concat(back);

//fazendo a mesma coisa com o spread operator
let fullStack = [...front, 'RxJS', ...back]
console.log(fullStack)//['react', 'vue','RxJS','python', 'nodejs']

console.log([...'will'])// ['w','i','l','l'] transformou a string em um array
console.log(...'will')// w i l l ele imprime como string
console.log(...front) // react vue ele imprime como string

```
Usando em funções
```
function makeSandwich(bread, cheese, sauce) {
  console.log(`Your sandwich with ${bread} bread, ${cheese} cheese and ${sauce} is done!`);
}
const ingredients = ['white', 'cheddar', 'barbecue'];
makeSandwich(...ingredients)
```

## Rest params

Ideal, quando não sabemos quantos argumentos vamos receber naquela função, e vamos receber isso como um array

```
//5*1
//5*2
//5*3
//5*4

//...args varios argumentos que vou receber como array
function multiply(mult, ...args) {
  //retorna um novo array [5,10,15,20]
  return args.map(arg => arg * mult);
}
console.log(multiply(5, 1, 2, 3, 4));
```
